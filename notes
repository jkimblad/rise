Great resource for Aly
    - https://github.com/llvm-mirror/llvm/blob/master/include/llvm/Target/TargetSchedule.td

LLVM- RESOURCE MODEL
    - For browsing the sourcecode in git, chose the stable branch.
    - Instructions are gathered in "SKLWriteResGroup" which define what ports are used, latency, and how many microOps goes into what port
    - IDEA: Use the LLVM resource model, but customize it to include the hold times that we have calculated from Agner's research.
        - Make the cusomization optional, so research can be done in how the scheduled instructions would differ.
        - Check if we can get access to Robertos TableGen backend, so we dont have to rewrit the wheel.
            - If not possible: Parse file using python, and then insert necessary information into the .yaml files used by specsgen.
            - Customization of specsgen is probably also necessary to use the information given in the yaml file
            - We could check with mats if itineraries are used for anything else, or if we can perhaps make itineraries from the class files in the .td file

    - Some instructions are pseudo/macro instructions. These are then expanded to real instructions. It seems right now that the unmatced instructions are the ones expanded from macjos, so we should look into the LLVM codebase to find their translations since they also need to have their resources defined.
        - Example from Mats: ".ex. expanderas FsFLD0SD (NoItinerary) till FsXORPDrr (IIC_SSE_BIT_P_RR), så i resursmodellen bör de vara ekvivalenta."
        - It may well be that instructions expanded from macros are covered by the definitions at the top of the skylake sched .td file
        - It may be that a macro instruction actually expands to several combined instructions.
            - Example, mov256 -> mov-low-128 and mov-high-128, thus mov256 is not a valid instruction, but simply an abstraction of several combined instructions
        - This seems to be a good resource for finding tranlations https://github.com/llvm-mirror/llvm/blob/68d73644cd5908c269d3c4419139ab2e6a85f527/lib/Target/X86/X86ExpandPseudo.cpp
        - Mats proposed that the macro-instructions might have the attribute "NoItinerary" in the x86.yaml file. Currently there are 1461 of these, and there are 1848 unmatched instructions

    - Some instructions seems to be abstracted even further and modeled as a group, for example "WriteIMul", it is unclear where the definitions of what instructions go into what group are.
        - Possible candidates for where to find the groupings:
            - X86/X86InstrArithmetic.td
            - X86/X86MCInstLower.cpp
                - DONE
                - This seems to be some of it (line 866), for example: Instruction add16i16 is not defined in our output, but here it is mapped to the instruction ADD16ri which actually is defined. ADD16ri is probably the macro/pseudo instruction.
                    - Note that sometimes the pseudo is not defined by the actual instruction is defined
            - X86/X86InstrInfo.td
                - Look for "WriteALU"
            - Search in x86 using "xxx path:/lib/Target/X86"

    - SchedRW groups defined as
        - WriteRes
            - "def : WriteRes<NAME, [PORTS]>;"
            - "def : WriteRes<NAME, [PORTS]>{
                LATENCY
                RESOURCECYCLES
            }"
        
        - SKLWriteResPair
            - "defm : SKLWriteResPair<NAME, PORTS, LATENCY>;"
            - Instructions that fit into here are possible to use with folded loads


Parsing Tablegen:
    - When running the python script that takes tablegen output as input, the tablegen command used should be "llvm-tblgen ~/Projects/llvm-6.0.0.src/lib/Target/X86/X86.td -InstrInfo -I ~/Projects/llvm-6.0.0.src/include -I ~/Projects/llvm-6.0.0.src/lib/Target/X86"

