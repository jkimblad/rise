LLVM extraction:
    ☐ Extract the instructions belonging to each "WriteResGroup"
        - Save in spreadsheet for easy extraction as *.csv later
    ☐ For pseudo/macro-instruction mapping to regular instructions, check "relaxed opcodes"
        - In some file, they map instructions to similar instructions in a
        function called something like "GetRelaxedOpcode", we should check if
        this is something that should be included, good idead is to check if
        both versions of the instruction is defined already or not.
    ✔ Look into if TableGen is a better way to go for this! @done(2018-06-27 17:28) @project(LLVM extraction)
        - We can probably parse the output created from tablegen w/o using a specific backend.
            - This is the right answer
    ☐ Make the program accept either a file as argument or stdin
    ☐ There is a bug where, if there for one defined instructions doesnt exist a defined SchedRW list, it parses until the next one which belongs to another instructions
        - This could be fixed by telling the parser to either exptecting a
        new instruction definition, in which case we throw away the
        earlier one, or expect a SchedRW list.
        - Look up the function ".find()" for strings, this will prob. be able
        to parse the file much faster, and make it easier to solve this problem

    




// All of this is put on hold for now, as we dont know how much it will actually be used right now
Throughputs:
    ✔ Calculate throughput correctly @done(2018-06-11 16:40) @project(Throughputs)
        -Given default prefix of ports, this should be calculated something like cardinality(largest port group) * reciprocal througput
    ✔ Correctly calculate largest cardinality @done(2018-06-11 11:26) @project(Throughputs)
        -We need to take into account to not include the ports that are used for load/store when searching for largest cardinality.
    ☐ Take care of edge-cases
        ☐ Make sure numerical prefixes are calculated correctly
            -This should be done by doing something like cardinality(largest port group)/prefix * reciprocal throughput
        ☐ Reciprocal throughput includes characters as "<, ~, n", etc. These need to be cared for
        ✔ Manually handle prefixes other than 'p' or numerical @done(2018-06-07 17:04) @project(Throughputs)
            -Note that there are no other prefixes other than p or numerics, this was a missunderstanding due to som of the fields containing words such as "none counted". These are caught during the RegEx check.
    ☐ Map names of instructions to LLVM-names for easier integration later 
    ✔ Consider missing fields @done(2018-06-08 11:19) @project(Throughputs)
        ✔ No reciprocal throughput @done(2018-06-08 11:19) @project(Throughputs)
        ✔ No ports defined @done(2018-06-08 11:19) @project(Throughputs)
            -Right now we catch instructions that have no ports defined, but still have a througput, might have to as Mats about these, but probably these will be included in the model, but hold no resources when sheduled.
    ☐ Integrate the throughputs in the Unison codebase
        -We will need to try and automatically map the instructions to LLVM names to do this automatically.          
        -This should probably be done in the *.td files, but check with Mats or Roberto first as they might know better
        -If included in *.td, the parser Roberto wrote which converts it into .yaml probably needs to be customized.
    ☐ Remove all instructions that are 32-bit execution mode
        -Not sure if this is needed, as we get it for free. Instructions were to focus on 64 bit.
            -This needs to be taken into consideration when mapping instructions to their LLVM names, so we dont accidently map a 32-bit instruction to a 64-bit name.
    ✔ Make sure that if we find a load/store match for the port-usage, we define the resource usage separately for those ports. @done(2018-06-11 11:25) @project(Throughputs)
        -Patterns that perform load/stores are,
            -p237 - STA
            -p23 - LD
            -p4 - STD
        -These probably hold a single resource for a single cycle
    ☐ There are instructions that have a larger prefix than cardinality
        - Example: 2p5, this screws up the calculations as we cant hold 2 of resource p5, as its resource value is just one.
        - Idea: Can this be fixed by just equating the prefix with the cardinality?
            - This is probably the solution, as other solutions would be harder to implement

Latencies:
    ☐ Integrate the google-compiler-teams researched latencies into the llvm codebase
        -This should probably be done in the *.td files, but check with Mats or Roberto first as they might know better

Misc:
    ✔ Get all unique collections of ports which represents resources in the processor @done(2018-06-11 16:39) @project(Misc)
    ✔ Create a DAG for the resources @done(2018-06-11 16:38) @project(Misc)

Refactoring:
    ☐ Rename variables to portsGroup, splitPortsGroup, ports, port to keep it consistent
    ☐ Make use of a function that removes numerical prefix from ports
    ☐ Handle all instruction as a list, instead of a string separated by newlines
    ☐ Remake "isPortDefined" to return true/false instead
        -Make check if length of match is the same as the length of string passed into the function
        -Probably rename this function to follow above refactoring as well

